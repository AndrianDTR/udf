#include "udfskatingrules.h"

#include "udfcommon.h"

udfSkatingRules::udfSkatingRules(int teams, int judges, int** marks)
: m_nTeams(teams)
, m_nJudges(judges)
, m_ppnMarks(0)
, m_ppnResults(0)
{
	int t = 0;
	m_ppnMarks = new int*[teams];
	m_ppnResults = new int*[teams];
	for(t = 0; t < teams; t++)
	{
		int j = 0;
		int r = 0;
		const int rc = teams + 1;
		
		m_ppnMarks[t] = new int[judges];
		m_ppnResults[t] = new int[rc];
		
		for(j = 0; j < judges; j++)
		{
			m_ppnMarks[t][j] = marks[t][j];
		}
		
		for(r = 0; r < rc; r++)
		{
			m_ppnResults[t][r] = 0;
		}
	}
}

udfSkatingRules::~udfSkatingRules()
{
	
	if(m_ppnMarks)
	{
		int t = 0;
		for(t = 0; t < m_nTeams; t++)
		{
			if(m_ppnMarks)
			{
				delete [] m_ppnMarks[t];
				m_ppnMarks[t] = 0;
			}
		}
		delete [] m_ppnMarks;
		m_ppnMarks = 0;
	}
	
	if(m_ppnResults)
	{
		int t = 0;
		for(t = 0; t < m_nTeams; t++)
		{
			if(m_ppnResults)
			{
				delete [] m_ppnResults[t];
				m_ppnResults[t] = 0;
			}
		}
		delete [] m_ppnResults;
		m_ppnResults = 0;
	}
}

bool udfSkatingRules::GetMarks(int& nTeams, int*** marks)
{
	Enter();
	bool res = true;
	
	do
	{
		if(Rule1())
			break;
		
		if(Rule2())
			break;
			
		if(Rule3())
			break;
		
		if(Rule4())
			break;
		
		if(Rule5())
			break;
		
		if(Rule6())
			break;
		
		if(Rule7())
			break;
		
		if(Rule8())
			break;
		
		if(Rule9())
			break;
		
		if(Rule10())
			break;
		
		if(Rule11())
			break;
		
		res = false;
	}while(0);
	
	nTeams = m_nTeams;
	*marks = m_ppnResults;
	
	Leave();
	return res;
}

/*******************************************************************************
 * Количество пар, которое должно быть отобрано в каждом туре соревнования для 
 * участия в следующем, определяется главным судьей (обычно это 2/3 но не менее 
 * 1/2 участвующих пар). В соответствии с этим решением судья должен отобрать в 
 * каждом танце указанное количество пар. Рекомендация: хотя способ обозначения 
 * выбора судьи правилами системы "скейтинг" строго не регламентирован, 
 * оптимальным способом обозначения являются:
 * - обозначение положительной оценки для отобранной пары по каждому танцу,
 * - зачеркивание или пропуск № пар, не выводимых судьей в следующий тур,
 * - буква "D" в случае дисквалификации пары.
 * 
 * Обычно отбирают по принципу "за - против". Равномерности выбора судьи по 
 * заходам может не быть. В следующий тур выводятся пары, имеющие наибольшие 
 * значения итоговых сумм. В процессе отбора может возникнуть ситуация, когда 
 * несколько пар имеют одинаковое значение итоговых сумм, позволяющее принять 
 * участие в следующем туре, но включение этих пар в состав участников 
 * следующего этапа проблематично, т.к. общее количество пар превысит заданное 
 * число. В этом случае главный судья и оргкомитет соревнований должны принять 
 * решение : либо допустить к участию в следующем туре все пары, имеющие 
 * одинаковое значение итоговых сумм, либо не допустить ни одну из них. 
 * Перетанцовку не допускают.
 ******************************************************************************/
bool udfSkatingRules::Rule1()
{
	return false;
}

/*******************************************************************************
 * В финале соревнующиеся пары должны быть расставлены судьей в каждом танце по 
 * местам согласно уровню их исполнительского мастерства.
 ******************************************************************************/
bool udfSkatingRules::Rule2()
{
	return false;
}

/*******************************************************************************
 * Лучшей, по мнению судьи паре, в каждом танце финала, ставится оценка "1" 
 * и т.д. Обычно в финальном туре соревнований принимают участие 6-8 пар.
 ******************************************************************************/
bool udfSkatingRules::Rule3()
{
	return false;
}

/*******************************************************************************
 * В финале судьи не имеют права ни в одном из танцев поставить двум или более 
 * парам одинаковую оценку.
 ******************************************************************************/
bool udfSkatingRules::Rule4()
{
	return false;
}

/*******************************************************************************
 * Победителем в отдельном танце становится пара, которая получает оценку "1" 
 * у большинства судей (не менее 3-х судей из 5-ти, 4-х из 6-ти или 7-ми, 5-ти 
 * из 8-ми или 9-ти судей). 2-е место присуждается паре, которая получит 2-е и 
 * более высокие оценки (т.е. 2-е и 1-е) у большинства судей. Остальные 
 * результаты за танец распределяются аналогичным образом. 
 * Колонки "оценки 1 - _" заполняются последовательно сверху - вниз и 
 * слева - направо, ни одну из них при обучении нельзя пропустить, т.к. 
 * в противном случае возникает опасность случайно не заметить претендента на 
 * очередной результат.
 * 
 * В случае, если ни одна из пар не набрала необходимого большинства голосов 
 * судей в рассматриваемой колонке оценок, надо для присвоения очередного места 
 * перейти к рассмотрению следующей колонки оценок "1-_". Как только результат, 
 * полученный парой в рассматриваемом танце определен, заполнение последующих 
 * построчных значений колонок оценок "1-_" для этой пары прекращают.
 * 
 * Пример А
 * № 	A 	B 	C 	D 	E 	1 	1-2 	1-3 	1-4 	1-5 	1-6 	Рез
 * 10 	3 	3 	3 	2 	3 	- 	1 		5 		  		  		  		3
 * 16 	6 	6 	6 	6 	5 	- 	- 		- 		- 		1 		5 		6
 * 24 	2 	2 	5 	4 	1 	1 	3 		  		  		  		  		2
 * 31 	4 	4 	2 	3 	4 	- 	1 		2 		5 		  		  		4
 * 45 	1 	5 	1 	1 	2 	3 	  		  		  		  		  		1
 * 48 	5 	1 	4 	5 	6 	1 	1 		1 		2 		4 		  		5
 * 
 * В примере А пара №45 от 3-х судей из 5-ти получила оценку "1" и вследствие 
 * этого становится победителем. Пары №10, №31, №48 не набрали необходимого 
 * большинства голосов судей в колонке "1-2" и поэтому их рассмотрение будет 
 * продолжено в следующих колонках. Пара №24 получила 2 раза 2-ю и один раз 
 * 1-ю оценку (итого 3 из 5-ти в колонке "1-2") и получает 2-й результат. 
 * Остальные результаты распределяются аналогично. Еще один пример к правилу 5,
 * для самостоятельного разбора.
 * 
 * Пример Б
 * № 	A 	B 	C 	D 	E 	1 	1-2 	1-3 	1-4 	1-5 	1-6 	Рез
 * 11 	1 	5 	1 	1 	2 	3 	  		  		  		  		  		1
 * 21 	2 	2 	5 	4 	1 	1 	3 		  		  		  		  		2
 * 32 	3 	3 	3 	2 	3 	- 	1 		5 		  		  		  		3
 * 41 	4 	4 	2 	3 	4 	- 	1 		2 		5 		  		  		4
 * 51 	5 	1 	4 	5 	5 	1 	1 		1 		2 		5 		  		5
 * 61 	6 	6 	6 	6 	6 	- 	- 		- 		- 		- 		5 		6
 ******************** 5 **********************************************************/
bool udfSkatingRules::Rule5()
{
	Enter();
	bool res = false;
	do
	{
		int jMost = m_nJudges / 2 + 1;
		
		__msg("most judges = %d", jMost);
		int t = 0;
		for(; t < m_nTeams; t++)
		{
			int* places = new int[m_nTeams];
			int p = 0;
			for(; p < m_nTeams; p++)
			{
				int j = 0;
				for(; j < m_nJudges; j++)
				{
					if(m_ppnMarks[t][j] == p+1)
					{
						places[p]++; 
					}
				}
			}
			
			for(p = 0; p < m_nTeams; p++)
			{
				m_ppnResults[t][p] = places[p];
			//	__msg("Team %d count for place %d is %d", t+1, p+1, places[p]);
			}
		}
		
		res = true;
	}while(0);
	
	Leave();
	return res;
}

/*******************************************************************************
 * В финале соревнующиеся пары должны быть расставлены судьей в каждом танце по 
 * местам согласно уровню их исполнительского мастерства.
 ******************************************************************************/
bool udfSkatingRules::Rule6()
{
	bool res = false;
	do
	{
		int jMost = m_nJudges / 2 + 1;
		
		
		res = true;
	}while(0);
	return res;
}

/*******************************************************************************
 * В финале соревнующиеся пары должны быть расставлены судьей в каждом танце по 
 * местам согласно уровню их исполнительского мастерства.
 ******************************************************************************/
bool udfSkatingRules::Rule7()
{
	bool res = false;
	do
	{
		int jMost = m_nJudges / 2 + 1;
		
		
		res = true;
	}while(0);
	return res;
}

/*******************************************************************************
 * В финале соревнующиеся пары должны быть расставлены судьей в каждом танце по 
 * местам согласно уровню их исполнительского мастерства.
 ******************************************************************************/
bool udfSkatingRules::Rule8()
{
	bool res = false;
	do
	{
		int jMost = m_nJudges / 2 + 1;
		
		
		res = true;
	}while(0);
	return res;
}

/*******************************************************************************
 * В финале соревнующиеся пары должны быть расставлены судьей в каждом танце по 
 * местам согласно уровню их исполнительского мастерства.
 ******************************************************************************/
bool udfSkatingRules::Rule9()
{
	bool res = false;
	do
	{
		int jMost = m_nJudges / 2 + 1;
		
		
		res = true;
	}while(0);
	return res;
}

/*******************************************************************************
 * В финале соревнующиеся пары должны быть расставлены судьей в каждом танце по 
 * местам согласно уровню их исполнительского мастерства.
 ******************************************************************************/
bool udfSkatingRules::Rule10()
{
	bool res = false;
	do
	{
		int jMost = m_nJudges / 2 + 1;
		
		
		res = true;
	}while(0);
	return res;
}

/*******************************************************************************
 * В финале соревнующиеся пары должны быть расставлены судьей в каждом танце по 
 * местам согласно уровню их исполнительского мастерства.
 ******************************************************************************/
bool udfSkatingRules::Rule11()
{
	bool res = false;
	do
	{
		int jMost = m_nJudges / 2 + 1;
		
		
		res = true;
	}while(0);
	return res;
}
